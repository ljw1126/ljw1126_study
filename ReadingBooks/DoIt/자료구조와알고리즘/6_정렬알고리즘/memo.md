## 6 정렬 알고리즘 

### [정렬 알고리즘]

#### 정렬(Sorting)이란?
``` 
 - 이름, 학번, 학점 등의 키(key)를 항목값의 대소 관계에 따라 데이터 집합을 일정한 순서로 바꾸어 늘어놓는 작업을 말함
 - 오름차순(ascending order) 정렬 : 작은 데이터 > 큰 데이터로 나열
   내림차순(descending order) 정렬 : 큰 데이터 > 작은 데이터로 나열 
 - 내부 정렬 : 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘
   외부 정렬 : 정렬할 데이터가 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘 
   
 ※ 정렬 알고리즘의 핵심은 교환/선택/삽입 ! 
```

#### 시간 복잡도 
| 명칭          | 시간 복잡도    | 
| ------------- |:-------------:| 
| 버블 정렬| O(n^2) |
| 선택 정렬| O(n^2) |  
| 삽입(셔틀) 정렬| O(n^2) |  
| 셸 정렬 | O(n^1.25) |
| 퀵 정렬 | O(n log n) | 
| 힙 정렬 | O(n log n) |
| 병합 정렬 | O(n log n) |
| 도수(계수) 정렬 | O(n) |

※ 퀵 정렬의 경우 원소 수가 적은 경우 그다지 빠른 알고리즘이 아님( 최악의 경우 시각 복잡도 O(n^2) )
<br/>




#### 1. 버블 정렬(Bubble sort, p221) 
```
 - 이웃한 두 원소의 대소 관계를 비교하여 필요에 따라 교환을 반복하는 알고리즘
 - 단순 교환 정렬이라고도 함  
 - 버블 정렬은 1칸 이상 떨어져 있는 원소를 교환하는 것이 아니라 서로 이웃한 원소만 교환하여 안정적
 
   (n-1) + (n-2) + ... + 1 = n(n-1)/2

```

| 예제          | 비교          | 
| ------------- |:-------------:| 
| bubble_sort| 비교21번/교환8번|
| bubble_sort2     | 비교18번/교환8번 |  
| bubble_sort3      | 비교12번/교환6번     |    
| bubble_shaker_sort.py | 비교10번/교환6번      |   

<br/>

###### ※ 출력문에 {a[i]:2} 의 뜻은 '우측정렬 후 좌측 2 공백해라'는 뜻 ( {} 포맷팅 )
><https://greendreamtrre.tistory.com/262>

<br/>
###### 파이썬 if 조건문 간단하게 표현하기 
```python
#1.일반적인 if .. else .. 문 

condition = True

if condition:
    x = 1
else:
    x = 0

print(x)

# 간단한 if .. else ..문  ( 참결과 if 조건문 else 거짓결과 )

condition = True

x = 1 if condition else 0

print(x)

---

# 2. 일반적인 if .. elif .. else 문
a = 30

if a > 100:
  print('Too Big')
elif a > 10:
  print('Big')
else:
  print('Small')

# 간단한 if .. elif .. else 문
a = 30

print('Too Big') if a > 100 else print('Big') if a > 10 else print('Small')

```
><https://codetorial.net/tips_and_examples/simple_if.html>

<br/>

#### 2. 단순 선택 정렬 (straight selection sort , p237)
```
 - 가장 작은 원소부터 선택해 알맞은 위치로 옮기는 작업을 반복하며 정렬하는 알고리즘 
 [방법]
  1) 아직 정렬하지 않은 부분에서 값이 가장 작은 원소 a[min]을 선택함 ( i (0 ~ len(array)-1일때 j는 i+1 ~ len(array)-1 만큼 돌며 작은 idx 구함)
  2) a[min]과 맨 앞에 있는 원소를 교환함 
 
 ' 중복값 있을시 중복된 값으로 정렬이 필요없는 데이터의 위치를 교환하므로 
 이 알고리즘은 안정적이지 않음 '
```

<br/>

#### 3. 단순 삽입 정렬 (straight insertion sort , p240)
```
- 주목한 원소보다 더 앞쪽에서 알맞은 위치로 삽입하며 정렬하는 알고리즘 
- 단순 선택 정렬과 비슷해 보이지만 값이 가장 작은 원소를 선택하지 않는다는 점이 다름
- 단순 삽입 정렬은 "셔틀 정렬(shuttle sort)"이라고도 합니다. 

장점 : 이미 정렬이 거의 끝나가는 상태에서는 속도가 아주 빠름 
단점 : 삽일할 위치가 멀리 떨어져 있으면 이동횟수가 많아짐 

```
##### ※ 단순 삽입 정렬 알고리즘은 파이썬 표준 라이브러리에서 bisect모듈의 insort()함수로 제공함 (예제 binary_insort.py)

<br/>

#### 4. 셸 정렬(shell sort) 
```
- 단순 삽일 정렬의 장점은 살이고 단점은 보완하고 더 빠르게 정렬하는 알고리즘 
- 도널드 L. 셸이 고안한 알고리즘 
- 셸 정렬은 먼저 정렬할 배열의 원소를 그룹으로 나눠 각 그룹별로 정렬 수행함 
- 그 후 정렬된 그룹을 합치는 작업을 반복하여 원소의 이동 횟수를 줄이는 방법 
  ※ 퀵 정렬 고안되기 전까지 가장 빠른 알고리즘이었다함 

- 셸 정렬의 시간복잡도는 O(n^1.25)로 단순 삽입 정렬보다 빠름 
  그러나 셸 정렬 알고리즘은 이웃하지 않고 떨어져 있는 원소를 서로 교환하므로 안정적이지 못함
```

##### shell_sort.py , shell_sort2.py 예제 참고

<br/>

#### 5. 퀵 정렬 (quick sort)
```
# x 피벗 , pl 왼쪽 , pr 오른쪽 인덱스
1) a[pl] >= x 가 성립하는 원소를 찾을 때까지 pl을 오른쪽 방향으로 스캔함 
2) a[pr] <= x 가 성립하는 원소를 찾을 때까지 pr를 왼쪽 방향으로 스캔함 

# pl , pr 교차 발생시 그룹을 나눔 
1) 피벗 이하인 그룹 : a[0] ~ a[pl-1]
2) 피벗 이상인 그룹 : a[pr+1] ~ a[n-1]
3) 피벗과 일치하는 그룹 : a[pr+1] ~ a[pl-1]

```
##### ※ p272 경우 퀵과 원소수 9미만일때 삽입정렬 변환인데, 설명 잘 읽고 이해하기

<br/>


#### 6. 병합 정렬(merge sort)
```
- 배열을 앞부분과 뒷부분의 두 그룹으로 나누어 각각 정렬한 후 병합하는 작업을 반복하는 알고리즘 
- 정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘
- 배열 병합의 시간 복잡도는 O(n) , 데이터의 원소 수가 n일 때 병합 정렬의 단계는 log n만큼 필요하므로 전체 시간 복잡도는 O(n log n) 입니다. 
- 병할 정렬 알고리즘은 안정적임 ( 서로 떨어져 있는 원소를 교환하는 것이 아니므로 )
```

```python
# sorted() 함수로 병합 정렬하기 
# 정렬을 마친(중요) 두 배열의 병합 


# a와 b를 연결하여 오름차순으로 정렬한 것을 list로 변환하여 c에 저장 
# 해당 메서드 사용시 정렬 x 상태여도 적용할 수 있다는 장점이 있지만, 속도가 빠르지 않다는 단점도 있음
c = list(sorted(a + b))  

# 빠르게 병합하려면 heapq모듈의 merge()를 사용하면 됨 
import heapq 

a = [2,4,6,8,11,13]
b = [1,2,3,4,9,16,21]
c = list(heapq.merge(a,b)) # 배열 a와 b를 병합하여 c에 저장 
```

<br/>

#### 7. 힙 정렬(heap sort)     // p286
```
- 힙의 특성을 이용하여 정렬하는 알고리즘 
- 힙은 '부모의 값이 자식의 값보다 항상 크다'는 조건을 만족하는 완전 이진 트리이다. 
( '부모의 값 ⪴ 자식의 값' 인 관계가 항상 성리함 ) 
- 특징 
  > '힙에서 최댓값은 루트에 위치한다'는 특징을 이용하여 정렬하는 알고리즘 
    >> 힙에서 최댓값인 루트를 꺼냅니다.
    >> 루트 이외의 부분을 힙으로 만듭니다.
- 즉, 힙 정렬은 선택 정렬을 응용한 알고리즘입니다. 
- 루트를 삭제한 힙의 재구성 
  > 1. 루트를 꺼냄 
  > 2. 마지막 원소(가장 하단의 가장 오른쪽에 위치한 원소)를 루트로 이동
  > 3. 루트에서 시작하여 자신보다 값이 큰 자식과 자리를 바꾸고 아래쪽으로 내려가는 작업을 반복합니다. 자식의 값이 작거나 리프의 위치에 도달하면 종료 ( ※ 왼쪽부터 비교 )
```

<br/>

#### 8. 도수 정렬(counting sort)  // p297 
```
- 원소의 대소 관계를 판단하지 않고 빠르게 정렬하는 알고리즘 
- 분포수 세기(distribution counting) 정렬이라고도 함
```