## 8. 리스트 

#### 8-1. 연결 리스트
```
- 연결 리스트에서 각 원소(element)를 노드(node)라고 함 
  > 노드는 데이터와 뒤쪽 노드를 가리키는(참조하는) 포인터(pointer) 가짐 
    >> 맨 앞에 있는 노드를 머리 노드 (head node)
    >> 맨 끝에 있는 노드를 꼬리 노드(tail node)
    >> 또 각 노드별 바로 앞에 있는 노드를 앞쪽 노드(predecessor node), 바로 뒤에 있는 노드를 뒤쪽 노드 (successor node)
```
- 단순 배열로 구현한 연결 리스트에는 다음과 같은 문제가 있슴 
  > 데이터 삽입/삭제함에 따라 데이터를 옮겨야 하므로 효율적이지 않음 

#### 8-2. 포인터를 이용한 연결 리스트 
```
- 연결 리스트에 데이터 삽입/삭제시 노드용 인스턴스로 처리하고 참조용 필드 next 통해 다음 노드 가르킴 
  > next 필드의 경우 자신과 같은 자료형의 인스턴스를 참조함 
- 이처럼 자신과 같은 형의 인스턴스를 참조하는 필드가 있는 구조를 자기 참조(self-referential)형이라 함 
```
- 파이썬의 리스트는 자료구조가 아닙니다. ( p325 참조 , 무슨 말인지 이해 안됨 , list와 배열의 차이 .. ??)
- 포인터를 이용한 연결 리스트는 '노드 삽입/삭제할 때 데이터를 이동하지 않고 처리'하는 특징이 있음 
  - 하지만 노드 삽입/삭제할 때마다 내부에서 노드용 인스턴스 생성/소멸하는 cost 발생 ! 

#### 8-3. 커서를 이용한 연결 리스트 (p343)
```
- 커서(cursor) : int형 정수값인 인덱스로 나타낸 포인터
  > 꼬리노드의 뒤쪽 커서는 -1 이다.
  > 머리노드의 뒤쪽 커서(인덱스)는 1이다.
- 이 방법은 노드의 삽입/삭제에 따른 원소의 이동이 처음부터 불필요하다는 점에서 포인터를 이용한 연결 리스트와 다름 
```
- 그림도 헷갈리는데 노드 삭제하게 되면 self.deleted에 삭제되는 노드 인덱스가 대입되고 , 삭제되는 노드의 dnext 속성에는 self.deleted 이전 값이 들어감 
  - 배열에 삭제되는게 아니라 포인터가 가르키지 않을 뿐이지 데이터 그대로 들어가 있음
  - deleted 되었을 때 아래와 같이 node dnext가 서로 가르키게 됨 
    idx -> 이전idx -> -1 
  - 그리고 노드 추가시 deleted가 -1아닌 경우 스택처럼(LIFO) 마지막에 삭제된 인덱스에 먼저 데이터 대입함 
- 배열에 Node Class형의 데이터 통해서 제어하는데, 교재 그림이 헷갈리게 함 

#### 8-4. 원형 이중 연결 리스트 (p356) 
```
- 원형 리스트(circular list) 는 꼬리노드가 다시 머리노드를 가르키는 모양을 하고 있음 
  > 마지막 꼬리 노드의 포인터가 None이 아닌 head가 됨 

- 연결 리스트의 가장 큰 단저믄 뒤쪽 노드를 찾기 쉬운 반면 앞쪽 노드를 찾기 어렵다는 것이었다 ! 이 단점을 개선한 리스트 구조가 이중 연결 리스트 이다.,

- 이중 연결 리스트(doubly linked list = bidirectional linked list 양방향 리스트) 각 노드에는 뒤쪽 노드에 대한 포인터 뿐만 아니라 앞쪽 노드에 대한 포인터가 주어짐 

- 원형 이중 연결 리스트(circular doubly linked list) 
  = 원형 리스트 + 이중 연결 리스트 
```
- prev, next 속성은 각 Node()를 가르킴 ( point* )
- self.head에 더미노드를 두고 삽입/삭제 이뤄짐
- self.current( 초기 = self.head = 더미노드) 주목노드 기준으로 삽입/삭제 수행됨 
- 더미노드 (self.head) 의 prev는 마지막 노드 혹은 자기자신(다른 노드 없을때)
- 더미노드 (self.head) 의 next는 헤더노드 혹은 자기자신(다른 노드 없을때)

