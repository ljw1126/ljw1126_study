## 1. Brute Force(완전탐색)
- 문제를 해결하기 위해 확인해야 하는 모든 경우를 전부 탐색하는 방법 
- 그 중에서도 백 트래킹(Back-Tracking)을 통해야 하는 상황을 해결하기 ! 
  - 모든 코테 문제에서 기본적으로 접근해 봐야한다. 많은 연습 필요 ! 
  - 부분점수 얻기 좋음 
  - 전부 탐색하기에 시간 복잡도가 일반적으로 높다.

#### 키워드 
- N 개 중에서 
  - 1) 중복을 허용해서 
  - 2) 중복없이
- M 개를 
  - A) 순서 있게 나열하기 
  - B) 고르기 

#### 완전 탐색은 함수 정의가 50% 
- 아래와 같은 형태로 문제 풀이 wlsdsa
```java
    // Recurrence Function ( 재귀함수 )
    // 만약 M개를 전부 고름 => 조건에 맞는 탐색을 한 가지 성공한 것! 
    // 아음 => k번째부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 시도한다.
    static void rec_func(int k){
        if(k == M + 1){
            // selected[1..M]배열이 새롭게 탐색된 결과
        }else{
            // 1~N까지 k번 원소로 한번씩 정하고,
            // 매번 k+1 번부터 M번 원소로 재귀호출해주기 
        }
    }

    public static void main(String[] args) {
        input();
        // 1번째 원소부터 M번째 원소를 조건에 맞게 고르는 모든 방법을 탐색해줘 
        rec_func();
        System.out.println(sb.toString());
    }

```

## 2. ㄴBinarySearch(이분/이진 탐색)
- **정렬이 보장되는 배열**에서 기준 x를 가지고 **범위를 '이분'**하면서 탐색하는 방법
  - **시간복잡도 O(log N)**
  - 이분 탐색은 정렬의 특성을 극대화함
- 이분 탐색 변수 셋팅 
  - L : 탐색할 가치가 있는 범위의 왼쪽 끝 인덱스 
  - R : 탐색할 가치가 있는 범위의 오른쪽 끝 인덱스 
    - M = (L+R)/2 중간 위치 인덱스 
  - result : 탐색한 x의 위치 
  - 탐색목포 : x 이하의 원소중에 가장 오른쪽에 있는 원소
- 자주 하는 실수 
  - 3위. L,R 범위를 잘못 설정하거나 result 초기값을 잘못 설정하는 경우
  - 2위. L,R,M,Result 변수의 정의를 헷갈려서 부등호 등을 잘못 쓰는 경우
  - 1위. 입력된 배열에 바로 이분 탐색을 하는데, 정렬을 하지 않는 경우

#### 매개 변수 탐색(Parametric Search)  -- 구현 구조는 이분탐색과 동일
- [핵심]
  - 정답을 "매개변수(parameter)"로 만들고 Yes/No문제(결정문제)로 바꿔보기
  - 모든 값에 대해서 yes/no를 채웠다고 생각(가정)했을때, 정렬된 상태인가?
  - Yes/No 결정하는 문제를 풀기!
- **문제를 거꾸로 푸는 것이기 때문에 통찰력 요구** 
  - 최근 코테에 빈도가 높아 중요하기때문에, 훈련이 많이 필요한 알고리즘!
- 자주 하는 실수 
  - 1위. 매개 변수에 대한 결정이 No Yes 꼴(정렬된 상태)이 아닌데 이분 탐색하는 경우.
  - 2위. L,R,M,Result 변수의 정의를 헷갈려서 부등호 등을 잘못쓰는 경우
  - 3위. L,R 범위를 잘못 설정하거나 Result의 초기값을 잘못 설정하는 경우

#### 키워드
  - **'~의 최댓값을 구하시오' , '~의 최솟값을 구하시오'**



## 3. 위상 정렬(Topological Sort)
- Directed Acyclic Graph(DAG)
- 단방향, 사이클 이루지 않은, 그래프 
- [정리] 
  - 1. 정점들의 Indegree, Indeg[1..N] 계산하기
  - 2. 들어오는 간선이 0개인(Indeg[i] == 0) 정점들을 찾아서 자료구조 D에 넣기 
  - 3. D가 빌 때까지  
    - 3-1. D에서 원소 X를 꺼내서 **'정렬'** 시키기
    - 3-2. Graph 에서 정점X **'제거'** 하기
    - 3-3. **'새롭게 정렬 가능한 점'** 을 찾아서 D에 넣기 
  - **O(|V| + |E|)**

## 4.두 포인터 (two pointer)
- 두 포인터 알고리즘이란 
  - 화살표 두 개에 의미를 부여해서 탐색 범위를 압축하는 방법
- 두 포인터 예시
  - 1. 1차원 배열 위에 2개의 포인터를 만드는 경우
    - 2개의 포인터가 모두 왼쪽에서 시작해서 **같은 방향**으로이동
    - 2개의 포인터가 양 끝에서 **서로를 향해** 이동
  - 2. 관찰을 통해서 문제에 등장하는 변수 2개의 값을 두 포인터로 표현하는 경우

#### 키워드
  - 1차원 배열에서의 **"연속 부분 수열"** or **"순서를 지키며 차례대로"**
  - **곱의 최소** 
    - 이런 단어가 등장하면 Two Pointers 접근을 시도해 볼 가치가 있다.


## 5. 최단 거리(Shortest Path)란?
- 그래프의 시작점에서 다른 지점까지의 최단 거리 
- BFS 리마인드
  - 탐색(Search) = 시작점에서 간선을 0개 이상 사용해서 갈 수 있는 정점들은 무엇인가?
  - 대표적으로 Depth First Search / Breadth First Search 
  - **BFS**의 경우 => 다른 정점 까지 **최소 이동 횟수도 계산가능**! (한번의 이동 == 간선의 가중치가 1)
- Dijkstra 알고리즘 요약 
  - Input(입력)
    - Graph G(V,E) := Nonnegative-Weighted Graph (가중치가 음수가 아닌 0 이상인)
    - Start Vertes S / Vertices {S1,...} BFS와 동일하게 시작점 한개 또는 여러개multisource이 주어져야함)
  - Output(출력결과)
    - 시작점에서 모든 점까지의 최단 거리 
  - Time Complexity(시간복잡도)
    - O(E log V)
  - 다익스트라 알고리즘에 필요한 정보 
    - dist[i] := 시작점에서 i번 정점까지의 가능한 최단 거리 (기재된 배열)
    - 자료구조 D := {(v,d)|시작점에서 v까지 d만에 갈 수 있음을 확인했다.}

## 6. 그래프(Graph)란?
- 자료구조로써 Graph = 정점(vertex) + 간선(edge)
  - 간선(Edge) → 무방향(양방향)/방향 + **가중치**
  - deg(x) = 정점 x의 차수(degree), 정점 x에 연결된 간선의 수 
    - ∑deg(x) = 모든 정점의 차수의 합 = 간선의 개수의 2배 ! ( 공식 알 것 !)
- Graph를 컴퓨터에 인식시키는 방식 (상황에 따라 선택사용) , 그래프를 저장하는 대표적인 두가지 방법
  - 1. 인접 행렬(Adjacency Matrix)
    - 2차원 배열 형태로 표현 
    - int[][] adj = int new [V][V];
    - **O(V^2)만큼 공간 필요**
    - A에서 B로 이동가능? 가중치 얼마? **O(1)에 해결 가능**
    - 정점 A에서 갈 수 있는 정점들은?  **O(V) 시간으로 해결가능(1번행 A라 할때)**
    - 만약 V = 10만 , E = 50만 일때 
      - V^2 = 100억 = 10 G(기가)    , 100억개의 공간/원소 필요 
      - Integer type으로 잡게 되면 40 G ? 계산이상함;;;
      - 실제 사용은 간선의 개수만큼 사용 > 공간 효율이 낮다 함 
  - 2. 인접 리스트(Adjacency List)
    - '연결된 것만 기록하자'
    - ArrayList<ArrayList<Intger>> adj;
    - **O(E)만큼의 공간필요** // 정점 x에 연결된 간선의 수 (=차수) 
      - V = 10만 , **E = 50만**
        - 5 * 10 ^5 = 500K 
    - A에서 B로 이동가능? 가중치 얼마?
      - O(min(deg(A),deg(B)))     // 양방향성인 경우 , A가 1이고 B가 3일때 
      - O(deg(A)) //방향성인 경우 
    - 정점A에서 갈수 있는 점점들은?
      - O(deg(A)) 

#### 포인트
|         | 인접행렬  |인접 리스트|
|:------:|:--------:|:--------:|
|A와 B를 잇는 간선 존재 여부 확인| **O(1)** | O(min(deg(A),deg(B))) |
|A와 연결된 모든 정점 확인| O(\|V\|) | **O(deg(A))** |
|공간 복잡도| O(\|V\|^2) | **O(\|E\|)** |

#### 탐색(Search)
- **시작점**에서 간선을 0개 이상 사용해서 **갈 수 있는 정점들은** 무엇인가?
  - 컴퓨터는 인접 리스트같은 자료구조로 확인가능 
  - 1. **깊이 우선 탐색(Depth First Search)**
  - 2. **너비 우선 탐색(Breadth First Search)**


#### 깊이 우선 탐색(DFS, Depth First Search)
- 인접 행렬 사용시 → O(V^2)
- 인접 리스트 → O( deg(1) + deg(2) + .. + deg(V) ) = O(E)     // V가 많으면 인접 리스트 사용하는게 좋음 

#### 너비 우선탐색(BFS, Breadth First Search)
- Queue가 들고 있는 자료의 의미 
  - 방문이 가능한 정점들은 찾을때, Queue에 해당 점정을 넣는다.
    - Queue에 정점이 남았다 → 아직 방문 가능한 점이 남아있다. or 탐색 중이다. 
    - Queue가 비어있다. → 시작점에서 갈 수 있는 모든 점을 찾아냈다! or 탐색이 끝났다!
  - 인접 행렬 사용시 → O(V^2)
  - 인접 리스트 → O( deg(1) + deg(2) + .. + deg(V) ) = O(E)     


#### '최소이동횟수','최단시간' 키워드
- 최소 "이동" 횟수와 관련된 것이기 대문에, 가중치에 대한개념이 없는 문제에서만 생기는 부가효과!
  - 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후 
  - 이동할 때 지나야 하는 **최소의 칸 수** 
  - 고슴도치가 안전하게 비버의굴로 이동하기 위해 **필요한 최소시간** 
- **때로는 그래프가 없는 문제에서 "정점"과 "간선"의 정의를 만들어서 그래프 문제로 접근해야함(중요!문제에는 그래프라고 설명안함)**