## 강의자료 
- **백준 사이트 정답 제출시 클래스명은 Main**으로 해야 동작함 ! [https://www.acmicpc.net/problem/문제번호](https://www.acmicpc.net/problem/문제번호)
- 깃허브에 올려둠 
[https://github.com/rhs0266/FastCampus/tree/main/](https://github.com/rhs0266/FastCampus/tree/main/)

## 두 포인터 (two pointer)
- 두 포인터 알고리즘이란 
  - 화살표 두 개에 의미를 부여해서 탐색 범위를 압축하는 방법
- 두 포인터 예시
  - 1. 1차원 배열 위에 2개의 포인터를 만드는 경우
    - 2개의 포인터가 모두 왼쪽에서 시작해서 **같은 방향**으로이동
    - 2개의 포인터가 양 끝에서 **서로를 향해** 이동
  - 2. 관찰을 통해서 문제에 등장하는 변수 2개의 값을 두 포인터로 표현하는 경우
- [키워드]
  - 1차원 배열에서의 **"연속 부분 수열"** or **"순서를 지키며 차례대로"**
  - **곱의 최소** 
    - 이런 단어가 등장하면 Two Pointers 접근을 시도해 볼 가치가 있다.

## 문제 링크 
|번호|명칭|난이도|주소|
|:------:|:--------:|:--------:|:--------------:|
|문제1|부분합|난이도3|[https://www.acmicpc.net/problem/1806](https://www.acmicpc.net/problem/1806)|
|추천문제||||
|추천1|수들의 합2|실버3(문제1비슷)|[https://www.acmicpc.net/problem/2003](https://www.acmicpc.net/problem/2003)|
|추천2|수열|실버3(for범위실수,또실수)|[https://www.acmicpc.net/problem/2559](https://www.acmicpc.net/problem/2559)|
|추천3|귀여운 라이언|실버1(직접품)|[https://www.acmicpc.net/problem/15565](https://www.acmicpc.net/problem/15565)|
|추천4|배열 합치기|실버5(직접품,병합정렬)|[https://www.acmicpc.net/problem/11728](https://www.acmicpc.net/problem/11728)|
|추천5|수 고르기|골드5(틀려서참고)|[https://www.acmicpc.net/problem/2230](https://www.acmicpc.net/problem/2230)|
|||||
|문제2|두 용액||[https://www.acmicpc.net/problem/2470](https://www.acmicpc.net/problem/2470)|
|추천문제||||
|추천6|두 수의 합|실버3(직접품)|[https://www.acmicpc.net/problem/3273](https://www.acmicpc.net/problem/3273)|
|||||
|응용1|List of Unique Numbers|난이도4(다시풀기)|[https://www.acmicpc.net/problem/13144](https://www.acmicpc.net/problem/13144)|
|응용2|좋다|난이도2|[https://www.acmicpc.net/problem/1253](https://www.acmicpc.net/problem/1253)|
|추천문제||||
|추천7|세 용액|어려움(로직이해x)|[https://www.acmicpc.net/problem/2473](https://www.acmicpc.net/problem/2473)|
|응용3|고냥이|난이도3(직접품!)|[https://www.acmicpc.net/problem/16472](https://www.acmicpc.net/problem/16472)|

//문제2. 두용액의 경우 이분 탐색에서 다룸 
//응용3. 고냥이의 경우 설명듣고 직접 품(정답) , 의도치않게 테크닉적인 내용도 해버림

#### 문제1. 부분합 
[https://www.acmicpc.net/problem/1806](https://www.acmicpc.net/problem/1806)
- 이 수열에서 연속된 수들의 부분합 중에 그 합이 S이상이 되는 것중, 가장 짧은 것의 길이를 구하는 프로그램 
- [정답의 최대치]
  - N = 100,000 (10 ≤ N < 100,000) , S = 10^8  (0 < S ≤ 100,000,000)
  - 정답이 N 이하이므로 Integer 범위, 모든 원소의 총합도 10^9이므로 Integer범위
- 시간복잡도 
  - O(N^2) 생각시 
    - 1. 왼쪽 시작 L 결정 => O(N)
    - 2. 오른쪽 끝을 R을 L부터 시작해서 이동 => O(N)
  - 투 포인터로 부분합을 구할 경우
    - L이 1일때 R이 5일때 S 조건을 충족했으니 그 이전은 볼필요없음(어차피 S 조건을 만족못하니)
    - L : 구간의 왼쪽 끝, R : 구간의 오른쪽 끝, Sum : [L..R] 구간의 합
      - 1. 왼쪽 시작 L의 이동 횟수 N번
      - 2. 오른쪽 끝 R을 이전의 단계 R(조건충족하는) 부터 시작해서 이동
      - 3. L,R이 각자 최대 N번 이동하니깐 **O(N)**

    | 5 | 1 | 3 | 5 | 10 | 7 | 4 | 9 | 2 | 8 |

|L\\R| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|1| 5  | 6 | 9 | 14 | 24 |    |    |    |    |     |
|2|    |(1)|(4)|(9) | 19 |    |    |    |    |     |
|3|    |   |(3)|(8) | 18 |    |    |    |    |     |
|4|    |   |   |(5) | 15 |    |    |    |    |     |
|5|    |   |   |    | 10 | 17 |    |    |    |     |
|6|    |   |   |    |    | 7  | 11 | 20 |    |     |
|7|    |   |   |    |    |    |(4) | 13 | 15 |     |
|8|    |   |   |    |    |    |    | (9)| 11 | 19 |
|9|    |   |   |    |    |    |    |    |(2) | 10 |
|10|   |   |   |    |    |    |    |    |    |  8 |


#### 문제2. 두 용액 
[https://www.acmicpc.net/problem/2470](https://www.acmicpc.net/problem/2470)
- 기존의 이분 검색 방법 사용시
  - 정렬 : O(NlogN)
  - 이분검색 : O(NlogN)
- 투 포인터 사용시 
  - L = "남아있는 것들 중" 제일 작은 원소, R = "남아 있는 것들 중" 제일 큰 원소 
  - **최소 + 최대 < 0 인 경우**
    - 가장 작은 애가 가장 큰 애를 더해도 음수라는 건데, 다른건 더 음수라는 뜻 
    - 최소 입장에서는 최선책을 만난 상태! 짝을 찾았으니 삭제(더 고려X)
    - **L을 삭제**
  - **최소+최대 > 0 인 경우**
    - 가장 큰애가 가장 작은 애를 더해도 양수라면 나머지랑 더해도 양수라는 뜻 
    - 최대 입장에서는 최선책을 만난 상태! 짝을 찾았으니 삭제(더 고려X)
    - **R을 삭제**
- 시간 복잡도 계산 
  - (정렬하지 않은 경우)
  - 1. 매 순간 L,R을 찾아야 한다 => O(N)
  - 2. 원소가 1개가 될 때까지 반복 => N번 반복
  - 3. 총 O(N^2)의 시간이 걸린다. => 시간초과 발생가능 
  - 그래서 정렬해보기 ! O(N log N)
  - 강의영상 26분에 도식화된 정보 있음 
  - **(정렬한 경우)**
  - 1. 배열 정렬 한번하기 => O(N log N)
  - 2. 매 순간 L,R로 계산한 후에 이동시키기 => O(N)
  - 3. 총 시간 복잡도 : **O(N log N)**


#### 응용1. List of Unique Numbers (난이도4)     --- 40분 고민해도 안되서 해설답안 참고함
[https://www.acmicpc.net/problem/13144](https://www.acmicpc.net/problem/13144)
- 정답의 최대치 
  - N = 100000 (1 ≤ N ≤ 100,000)
  - 모든 연속 구간이 모두 정답에 카운트 된다 
  - 그러한 개수가 N! = 50억 정도 => **long으로 해야함 !**
- 가장 쉬운 방법 O(N^3)
  - 1. 왼쪽 시작 L 결정 => O(N)
  - 2. 오른쪽 끝을 R을 L부터 시작해서 이동 => O(N)
  - 3. R을 이동애서 추가된 원소가 [L,R-1]안에 있는지 확인  => O(N)
  - 총 O(N^3)
- 개선된 방법 O(N^2)
  - 1. 왼쪽 시작 L 결정 => O(N)
  - 2. 오른쪽 끝을 R을 L부터 시작해서 이동 => O(N)
  - 3. R을 이동해서 추가된 원소가 [L,R-1]안에 있는지 확인 => O(1)   //count배열에 값이 1이면 있다는 게 확인되니 
  - 숫자마다 [L,R]안에 몇개나 있는지를 직접 세자! => count sorting  
  - count라는 배열을 L,R이동시 잘 처리 해야함
- 투 포인터 방법 O(N) // **count 배열과 포인트 이동하면서 카운트를 누적해서 결과 구함**
  - 1. 왼쪽 시작 L의 이동 횟수 N 번 
  - 2. 오른쪽 끝 R을 **이전의 R**부터 시작해서 이동 // ?
  - 3. R을 이동해서 추가된 원소가 [L,R-1]안에 있는 지 확인 => O(1)
  - L , R이 각자 최대 N번 이동하니깐 , O(N)

#### 응용2 좋다 -- while문에 중복 내용은 넘어가도록 하는게 필요
[https://www.acmicpc.net/problem/1253](https://www.acmicpc.net/problem/1253)
- 정답의 최대치 확인 
  - 원소 개수 N (1 ≤ N ≤ 2,000) => Integer 범위
  - 원소 두개의 합도 최대 10^9 이므로 => Integer 범위 
- 가장 쉬운 방법 O(N^3)
  - 1. 타겟 수 결정 => O(N)
  - 2. 다른 수 2개 결정해서 만들어지나 확인 => O(N^2)
  - 3. O(N^3) => **시간초과**
- ※ 두 용액 문제 생각해보기 => 비슷한 숫자를 더해 0에 가까운 유형 구하는 문제였음
  - 1. 정렬한번 => O(NlogN)
  - 2. 타겟 수 결정 => O(N)
  - 3. 다른 수 2개 결정해서 만들어지나 확인 => O(N)
  - 4. 최종적으로 O(N^2)
- 방식 : L을 먼저 이동하고 R을 맞춰 이동하는 방식 //?

#### 응용3. 고냥이 ---------- 골드 3
[https://www.acmicpc.net/problem/16472](https://www.acmicpc.net/problem/16472)
- 강의 21 부터 설명 들으면 됨 
- '최대 N개의 종류의 알파벳을 가진 **연속된 문자열** 밖에 인식하지 못한다. 인식할 수 있는 최대 문자열의 길이는 얼마인지가 궁금해졌다.'
- 정답의 최대치 
  - N = 26 이라면 문자열 전체를 인식하므로, 최대 길이인 10만이 정답이다. => Integer로 충분 
- 바로 투 포인터로 접근!
  - cnt 배열을 만듦 , L = 인식 가능한 가장 왼쪽 위치, R = 인식하고 싶은 구간의 오른쪽 끝
  - kind = [L,R]사이의 알파벳 종류 , 즉 cnt 배열에서 0이 아닌 것의 개수
- 시간/공간 복잡도 
  - 1. R을 하나씩 이동ㅇ시키면서 L을 조절하기 => O(N)
  - 2. kind 를 O(26)에 계산하거나 O(1)에 계산 가능!
  - 3. 총 시간 복잡도 0(N)
- 방식 : R을 먼저 고정하고 L을 맞춰 이동  //?